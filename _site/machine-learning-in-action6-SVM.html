<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>机器学习实战（6）--支持向量机SVM | liubaojie's site</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/css/favicon.ico" type="image/x-icon" />
  <link rel="icon" href="/css/favicon.ico" mce_href="/favicon.ico" type="image/x-icon">
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>

<body>
  <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
  html {
    background: #333333;
    -webkit-background-size: cover;
    -moz-background-size: cover;
    -o-background-size: cover;
    background-size: cover;
  }
  @media screen and (max-width: 750px){
    body { background: rgba(255, 255, 255, 0.9); }
  }
</style>

<div id="content" class="post" style="margin-top: 20px;">
  <div id="avatar" class="avatar circle" data-in-right="false" style="width: 150px; height: 150px; position: fixed; top: 40px; z-index: 99; opacity: 0;">
    <div class="center" style="margin-top: 4px; height: 142px; width: 142px; border-radius: 71px; background-image: url('../images/user.png');"></div>
  </div>

  <div class="entry" style="position: relative;">
    <h1 class="entry-title"><a href="/machine-learning-in-action6-SVM" title="机器学习实战（6）--支持向量机SVM">机器学习实战（6）--支持向量机SVM</a></h1>

    <p class="entry-date">2016-07-03 
        <span class="lastModified" style="display: none;" data-source="_posts/read/2016-07-03-machine-learning-in-action6-SVM.md">最后更新时间: 
        </span>
    </p>


    <h1 id="section">支持向量机</h1>

<blockquote>
  <p>SVM是最好的现成分类器，“现成”指的是分类器不加修改可以直接使用。<br />
本章将使用最流行的一种实现，即序列最小优化（Sequence Minimum Optimization，SMO）算法。</p>
</blockquote>

<h2 id="section-1">6.1基于最大间隔分隔数据</h2>
<p><img src="images/SVM1.png" alt="image" /></p>

<ul>
  <li>将数据集分割开来的直线称为分隔超平面（separating hyperplane）。</li>
  <li>我们希望找到离分割超平面最近的点，确保它们离分隔面的距离尽可能远。</li>
  <li>支持向量（support vector）就是离分割超平面最近的哪些点。</li>
</ul>

<h2 id="section-2">6.2寻找最大间隔</h2>
<p><img src="images/SVM2.png" alt="image" /></p>

<p>分割超平面的形式可以写成这样：
<code class="highlighter-rouge">math
W^{T}X+b
</code>
要描述A到分割超平面的距离，就必须给出点到分隔面的法线长度：
<code class="highlighter-rouge">math
|W^{T}A+b|/||W||
</code></p>

<h3 id="section-3">6.2.1分类器求解的优化问题</h3>

<p>这里的类别标签用-1和1，而不是0和1，以便用统一的公式来表示间隔或者数据点到分隔超平面的距离而不用担心数据到底是属于-1还是1类。<br />
现在的目标就是找出分类器定义中的W和b。为此，我们必须找到具有最小间隔的数据点，也就是支持向量。一旦找到具有最小间隔的数据点，就需要对该间隔最大化：</p>

<p><img src="images/1.jpg" alt="image" /></p>

<p>直接求解这个问题很麻烦，所以用拉格朗日乘子法，通过引入拉格朗日乘子可以基于约束条件来表达原问题（尖括号表示两个向量的内积）：</p>

<p><img src="images/2.jpg" alt="image" /></p>

<p>引入松弛变量后约束条件变为：</p>

<p><img src="images/3.jpg" alt="image" /></p>

<p>这里用常数C来控制“最大化间隔”和“保证大部分点的函数间隔小于1.0”这两个目标权重。</p>

<h2 id="smo">6.3SMO高效优化算法</h2>

<p>要对上一节的两个式子进行优化，一个是目标函数，一个是约束条件。</p>

<h3 id="plattsmo">6.3.1Platt的SMO算法</h3>

<p>SMO（Sequence Minimal Optimization）。是将大优化问题分解为多个小优化问题来求解。这些小优化问题往往很容易求解，并且对他们进行顺序求解的结果与将它们作为整体来求解的结果是一致的。<br />
SMO算法的原理是：每次循环之中选择两个合适的alpha进行优化。一旦找到，就同时减少其中一个，增大另外一个。alpha满足的条件有：①两个alpha必须在边界之外；②alpha还没有进行区间优化处理或者不在边界上。</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#SMO算法中的辅助函数</span>
<span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
	<span class="n">dataMat</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">labelMat</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">fr</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
		<span class="n">lineArr</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
		<span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
		<span class="n">labelMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
	<span class="k">return</span> <span class="n">dataMat</span><span class="p">,</span><span class="n">labelMat</span>
	
<span class="k">def</span> <span class="nf">selectJrand</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
	<span class="n">j</span><span class="o">=</span><span class="n">i</span>
	<span class="k">while</span> <span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">:</span>
		<span class="n">j</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">j</span>
<span class="c">#其中i是alpha的下标，m是alpha的个数</span>

<span class="k">def</span> <span class="nf">clipAlpha</span><span class="p">(</span><span class="n">aj</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">aj</span><span class="o">&gt;</span><span class="n">H</span><span class="p">:</span>
		<span class="n">aj</span><span class="o">=</span><span class="n">H</span>
	<span class="k">if</span> <span class="n">aj</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span>
		<span class="n">aj</span><span class="o">=</span><span class="n">L</span>
	<span class="k">return</span> <span class="n">aj</span>
<span class="c">#用于调整大于H或者小于L的alpha值</span>
</code></pre>
</div>

<p>SMO的伪代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>创建一个alpha向量，初始化为0向量
当迭代次数小于最大迭代次数时（外循环）
    对数据集的每个数据向量（内循环）：
        如果该数据向量可以被优化：
            随机选择另一个数据向量
            同时优化这两个
            如果两个都不能被优化，退出内循环
    如果所有向量都未被优化，增加迭代数目，进入下一次循环
</code></pre>
</div>
<p>简化版SMO代码如下：</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#辅助函数</span>
<span class="k">def</span> <span class="nf">loadDataSet</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
	<span class="n">dataMat</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">labelMat</span><span class="o">=</span><span class="p">[]</span>
	<span class="n">fr</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fr</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
		<span class="n">lineArr</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">'</span><span class="p">)</span>
		<span class="n">dataMat</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
		<span class="n">labelMat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">lineArr</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
	<span class="k">return</span> <span class="n">dataMat</span><span class="p">,</span><span class="n">labelMat</span>
<span class="k">def</span> <span class="nf">selectJrand</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
	<span class="n">j</span><span class="o">=</span><span class="n">i</span>
	<span class="k">while</span> <span class="n">j</span><span class="o">==</span><span class="n">i</span><span class="p">:</span>
		<span class="n">j</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">j</span>

<span class="k">def</span> <span class="nf">clipAlpha</span><span class="p">(</span><span class="n">aj</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
	<span class="k">if</span> <span class="n">aj</span><span class="o">&gt;</span><span class="n">H</span><span class="p">:</span>
		<span class="n">aj</span><span class="o">=</span><span class="n">H</span>
	<span class="k">if</span> <span class="n">aj</span><span class="o">&lt;</span><span class="n">L</span><span class="p">:</span>
		<span class="n">aj</span><span class="o">=</span><span class="n">L</span>
	<span class="k">return</span> <span class="n">aj</span>

<span class="n">dataArr</span><span class="p">,</span><span class="n">labelArr</span><span class="o">=</span><span class="n">loadDataSet</span><span class="p">(</span><span class="s">'D:/BaiduYunDownload/MLinaction/Ch06/testSet.txt'</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">smoSimple</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">,</span><span class="n">classLabels</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">toler</span><span class="p">,</span><span class="n">maxIter</span><span class="p">):</span>
<span class="c"># dataMatIn: 数据集</span>
<span class="c"># classLabels：类别标签</span>
<span class="c"># toler：容错率</span>
<span class="c"># maxIter：最大循环次数</span>
	<span class="n">dataMatrix</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="n">dataMatIn</span><span class="p">);</span><span class="n">labelMat</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
	<span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">dataMatrix</span><span class="o">.</span><span class="n">shape</span>
	<span class="n">alphas</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
	<span class="nb">iter</span><span class="o">=</span><span class="mi">0</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">iter</span><span class="o">&lt;</span><span class="n">maxIter</span><span class="p">):</span>
		<span class="n">alphaPairsChanged</span><span class="o">=</span><span class="mi">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
			<span class="n">fXi</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span><span class="n">labelMat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="n">dataMatrix</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">+</span><span class="n">b</span>
			<span class="n">Ei</span><span class="o">=</span><span class="n">fXi</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="c">#如果alpha可以优化进入优化过程</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Ei</span><span class="o">&lt;</span> <span class="o">-</span><span class="n">toler</span> <span class="ow">and</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">C</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Ei</span><span class="o">&gt;</span><span class="n">toler</span> <span class="ow">and</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
				<span class="n">j</span><span class="o">=</span><span class="n">selectJrand</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">)</span><span class="c">#随机选择第二个alpha</span>
				<span class="n">fXj</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span><span class="n">labelMat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="p">(</span><span class="n">dataMatrix</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">+</span><span class="n">b</span>
				<span class="n">Ej</span><span class="o">=</span><span class="n">fXj</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="n">alphaIold</span><span class="o">=</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="n">alphaJold</span><span class="o">=</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
					<span class="c">#保证alpha在0到C之间</span>
					<span class="n">L</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
					<span class="n">H</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">C</span><span class="o">+</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">L</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">C</span><span class="p">)</span>
					<span class="n">H</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="n">H</span><span class="p">:</span>
					<span class="k">print</span> <span class="s">"L==H"</span><span class="p">;</span><span class="k">continue</span>
				<span class="n">eta</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span>\
						<span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span>\
						<span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
				<span class="k">if</span> <span class="n">eta</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span> <span class="k">print</span> <span class="s">"eta&gt;=0"</span><span class="p">;</span> <span class="k">continue</span>
				<span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-=</span><span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">Ei</span><span class="o">-</span><span class="n">Ej</span><span class="p">)</span><span class="o">/</span><span class="n">eta</span>
				<span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">clipAlpha</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">H</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphaJold</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.000001</span><span class="p">:</span>
					<span class="k">print</span> <span class="s">"j not moving enough"</span><span class="p">;</span><span class="k">continue</span>
				<span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphaJold</span><span class="o">-</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
				<span class="n">b1</span><span class="o">=</span><span class="n">b</span><span class="o">-</span><span class="n">Ei</span><span class="o">-</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">alphaIold</span><span class="p">)</span><span class="o">*</span>\
					<span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span>\
					<span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphaJold</span><span class="p">)</span><span class="o">*</span>\
					<span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
				<span class="n">b2</span><span class="o">=</span><span class="n">b</span><span class="o">-</span><span class="n">Ej</span><span class="o">-</span><span class="n">labelMat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">alphaIold</span><span class="p">)</span><span class="o">*</span>\
					<span class="n">dataMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="o">-</span>\
					<span class="n">labelMat</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">alphaJold</span><span class="p">)</span><span class="o">*</span>\
					<span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">*</span><span class="n">dataMatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
				<span class="k">if</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">C</span><span class="p">:</span> 
					<span class="n">b</span><span class="o">=</span><span class="n">b1</span>
				<span class="k">elif</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">alphas</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">C</span><span class="p">:</span> 
					<span class="n">b</span><span class="o">=</span><span class="n">b2</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="n">b1</span><span class="o">+</span><span class="n">b2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
				<span class="n">alphaPairsChanged</span><span class="o">+=</span><span class="mi">1</span>
				<span class="k">print</span> <span class="s">"iter: </span><span class="si">%</span><span class="s">d i: </span><span class="si">%</span><span class="s">d,pairs changed </span><span class="si">%</span><span class="s">d"</span><span class="o">%</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">alphaPairsChanged</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alphaPairsChanged</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        	<span class="nb">iter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
        	<span class="nb">iter</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">"iteration number : </span><span class="si">%</span><span class="s">d"</span><span class="o">%</span><span class="nb">iter</span>
	<span class="k">return</span> <span class="n">b</span><span class="p">,</span><span class="n">alphas</span>

<span class="n">b</span><span class="p">,</span><span class="n">alphas</span><span class="o">=</span><span class="n">smoSimple</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span><span class="n">labelArr</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.001</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="images/SVMsmo.png" alt="image" /></p>

<p>程序在运行上比较慢，但只是为了了解下思路，毕竟是要成为调包侠的男人。</p>

<h2 id="section-4">6.5在复杂数据上应用核函数</h2>
<p><img src="images/SVMh.png" alt="image" /></p>

<p>上图的数据集明显存在模式，但是很难用一条直线分割，这里就需要用到核函数（kernel）了。</p>

<h3 id="section-5">6.5.1利用核函数将数据集映射到高维空间</h3>
<p>核函数可以从某个很难处理的形式转换为另一个比较容易处理的形式。经过空间转换后我们可以在高维空间解决线性问题，相当于在低维空间解决非线性问题。<br />
SVM优化中一个很好的地方就是，所有的运算都可以写成内积的形式，我们可以把内积运算写成核函数，而不必做简化处理。将内积替换成核函数的方式成为<strong>核技巧（kernel trick）</strong>，或者核“变电”（kernel substation）。<br />
### 6.5.2径向核函数
径向核函数直接以向量作为自变量，能够基于向量的距离运算输出一个标量。这个距离可以是从&lt;0,0&gt;向量或者其他向量开始计算的距离。高斯版本的形式：</p>

<p><img src="images/SVMk.png" alt="image" /></p>

<p>上述高斯核函数将数据从其特征空间映射到一个无穷维的空间。<br />
后面的核函数的应用就不怎么看得懂了，<a href="http://scikit-learn.org/stable/modules/svm.html#kernel-functions">Kernel functions</a>。</p>



  </div>


  <div id="menuIndex" class="sidenav">
    <div class="myinfo"><center>
      <div id="avatarHolder" class="avatar circle" style="width: 0px; height: 0px; box-shadow: none; margin-bottom: 20px;"></div>
      <a href="/index.html" title="Homepage"><i class="icon-home icon-large"></i> Home</a>
      <a href="http://www.linkedin.com/in"><i class="icon-linkedin-sign icon-large"></i> Profile</a>
      <a href="https://github.com/"><i class="icon-github icon-large"></i> Code</a>
      <a href="mailto:liubaojie2016@163.com"><i class="icon-envelope icon-large"></i> Mail</a>
    </center></div>
    <div id="menu"></div>
  </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>

</body>


</html>
