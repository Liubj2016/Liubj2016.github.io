<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>机器学习实战（7）--利用AdaBoost元算法提高分类器性能 | liubaojie's site</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/css/favicon.ico" type="image/x-icon" />
  <link rel="icon" href="/css/favicon.ico" mce_href="/favicon.ico" type="image/x-icon">
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>

<body>
  <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
  html {
    background: #333333;
    -webkit-background-size: cover;
    -moz-background-size: cover;
    -o-background-size: cover;
    background-size: cover;
  }
  @media screen and (max-width: 750px){
    body { background: rgba(255, 255, 255, 0.9); }
  }
</style>

<div id="content" class="post" style="margin-top: 20px;">
  <div id="avatar" class="avatar circle" data-in-right="false" style="width: 150px; height: 150px; position: fixed; top: 40px; z-index: 99; opacity: 0;">
    <div class="center" style="margin-top: 4px; height: 142px; width: 142px; border-radius: 71px; background-image: url('../images/user.png');"></div>
  </div>

  <div class="entry" style="position: relative;">
    <h1 class="entry-title"><a href="/machine-learning-in-action7-AdaBoost" title="机器学习实战（7）--利用AdaBoost元算法提高分类器性能">机器学习实战（7）--利用AdaBoost元算法提高分类器性能</a></h1>

    <p class="entry-date">2016-07-14 
        <span class="lastModified" style="display: none;" data-source="_posts/read/2016-07-14-machine-learning-in-action7-AdaBoost.md">最后更新时间: 
        </span>
    </p>


    <h2 id="section">7.1基于数据集多重抽样的分类器</h2>
<p>我们将不同的分类器组合起来，这种组合的结果被称为集成方法（ensemble method）或者元算法（meta-algorithm）。</p>

<p>AdaBoost的优缺点：</p>

<ul>
  <li>优点：泛化错误率低，易编码，可以应用在大部分分类器上。</li>
  <li>缺点：对离群点较敏感。</li>
</ul>

<h3 id="bagging">7.1.1bagging：基于数据随机重抽样的分类器构建方法</h3>
<p>从原始的数据集上随机放回地抽取S次得到新数据集S个，与原数据集的大小相等，然后将某个学习算法应用于这S个数据集就相当于得到了S个分类器，选择分类器投票结果中最多的类别作为最后的分类结果。随机森林（random forest）就是一种先进的bagging方法。</p>

<h3 id="boosting">7.1.2boosting</h3>
<ul>
  <li>与bagging类似的技术。</li>
  <li>boosting是关注被已有的分类器错分的那些数据来获得新的分类器。</li>
  <li>bagging的每个分类器的权重是一样的，而boosting的分类器的权重代表其对应分类器在上一轮迭代中的成功度。</li>
  <li>boosting有多种版本，AdaBoost最为流行。</li>
</ul>

<hr />

<h2 id="section-1">7.2训练算法：基于错误提升分类器性能</h2>
<blockquote>
  <p>能否使用弱分类器来构造强分类器呢？这是个有趣的问题。所谓弱分类器意味着分类器的性能比随机猜测的性能略好，而强分类器的错误率就要低很多。</p>
</blockquote>

<p>AdaBoost的运算如下:</p>
<ol>
  <li>训练数据中的每个样本，并赋予其一个权重D（一开始权重都相等）；</li>
  <li>训练出一个弱分类器，并计算出分类器的错误率；</li>
  <li>进行二次训练，根据错误率调整权重，其中分对的样本权重变低，错的样本权重变高；</li>
</ol>

<p>其中错误率的定义为:  e=未正确分类的样本数目/所有样本数目 <br />
每个分类器权重alpha的计算公式为：  alpha=0.5*ln(1-e/e)</p>

<p><strong>注意：样本的权重是D，分类器的权重是alpha！</strong></p>

<p>如果样本被正确分类，那么更新它的权重如下：<br />
<img src="images/ada1.png" alt="image" /><br />
如果样本被错误分类，那么更新它的权重如下：<br />
<img src="images/ada2.png" alt="image" /></p>

<hr />

<h2 id="section-2">7.3基于单层决策树构建的弱分类器</h2>
<p><img src="images/ada3.png" alt="image" /></p>

<p>要想把上图中的数据点用一条平行于坐标轴的直线分开显然是不可能的。单层决策树难以处理这种问题。</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stumpClassify</span><span class="p">(</span><span class="n">dataMatrix</span><span class="p">,</span><span class="n">dimen</span><span class="p">,</span><span class="n">threshVal</span><span class="p">,</span><span class="n">threshIneq</span><span class="p">):</span><span class="c">#just classify the data</span>
    <span class="n">retArray</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="n">shape</span><span class="p">(</span><span class="n">dataMatrix</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">threshIneq</span> <span class="o">==</span> <span class="s">'lt'</span><span class="p">:</span>
        <span class="n">retArray</span><span class="p">[</span><span class="n">dataMatrix</span><span class="p">[:,</span><span class="n">dimen</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshVal</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">retArray</span><span class="p">[</span><span class="n">dataMatrix</span><span class="p">[:,</span><span class="n">dimen</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshVal</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">retArray</span>

<span class="k">def</span> <span class="nf">buildStump</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span><span class="n">classLabels</span><span class="p">,</span><span class="n">D</span><span class="p">):</span>
    <span class="n">dataMatrix</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">dataArr</span><span class="p">);</span> <span class="n">labelMat</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">dataMatrix</span><span class="p">)</span>
    <span class="n">numSteps</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span> <span class="n">bestStump</span> <span class="o">=</span> <span class="p">{};</span> <span class="n">bestClasEst</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">minError</span> <span class="o">=</span> <span class="n">inf</span> <span class="c">#init error sum, to +infinity</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span><span class="c">#loop over all dimensions</span>
        <span class="n">rangeMin</span> <span class="o">=</span> <span class="n">dataMatrix</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="nb">min</span><span class="p">();</span> <span class="n">rangeMax</span> <span class="o">=</span> <span class="n">dataMatrix</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="nb">max</span><span class="p">();</span>
        <span class="n">stepSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">rangeMax</span><span class="o">-</span><span class="n">rangeMin</span><span class="p">)</span><span class="o">/</span><span class="n">numSteps</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">numSteps</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span><span class="c">#loop over all range in current dimension</span>
            <span class="k">for</span> <span class="n">inequal</span> <span class="ow">in</span> <span class="p">[</span><span class="s">'lt'</span><span class="p">,</span> <span class="s">'gt'</span><span class="p">]:</span> <span class="c">#go over less than and greater than</span>
                <span class="n">threshVal</span> <span class="o">=</span> <span class="p">(</span><span class="n">rangeMin</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">stepSize</span><span class="p">)</span>
                <span class="n">predictedVals</span> <span class="o">=</span> <span class="n">stumpClassify</span><span class="p">(</span><span class="n">dataMatrix</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">threshVal</span><span class="p">,</span><span class="n">inequal</span><span class="p">)</span><span class="c">#call stump classify with i, j, lessThan</span>
                <span class="n">errArr</span> <span class="o">=</span> <span class="n">mat</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
                <span class="n">errArr</span><span class="p">[</span><span class="n">predictedVals</span> <span class="o">==</span> <span class="n">labelMat</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">weightedError</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">errArr</span>  <span class="c">#calc total error multiplied by D</span>
                <span class="k">print</span> <span class="s">"split: dim </span><span class="si">%</span><span class="s">d, thresh </span><span class="si">%.2</span><span class="s">f, thresh ineqal: </span><span class="si">%</span><span class="s">s, the weighted error is </span><span class="si">%.3</span><span class="s">f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">threshVal</span><span class="p">,</span> <span class="n">inequal</span><span class="p">,</span> <span class="n">weightedError</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">weightedError</span> <span class="o">&lt;</span> <span class="n">minError</span><span class="p">:</span>
                    <span class="n">minError</span> <span class="o">=</span> <span class="n">weightedError</span>
                    <span class="n">bestClasEst</span> <span class="o">=</span> <span class="n">predictedVals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">bestStump</span><span class="p">[</span><span class="s">'dim'</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">bestStump</span><span class="p">[</span><span class="s">'thresh'</span><span class="p">]</span> <span class="o">=</span> <span class="n">threshVal</span>
                    <span class="n">bestStump</span><span class="p">[</span><span class="s">'ineq'</span><span class="p">]</span> <span class="o">=</span> <span class="n">inequal</span>
    <span class="k">return</span> <span class="n">bestStump</span><span class="p">,</span><span class="n">minError</span><span class="p">,</span><span class="n">bestClasEst</span>
</code></pre>
</div>
<p>上述代码构造了一个决策树的简化版本，是一个弱分类器。接下来就可以构造AdaBoost分类器了。</p>

<hr />

<h2 id="adaboost">7.4完整AdaBoost算法的实现</h2>
<p>之前构造了一个基于加权输入值来进行决策的分类器，现在将有了实现一个完整AdaBoost算法所需要的所有信息。实现的的伪代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>对每次迭代：
    利用buildStump()函数找到最佳的单层决策树
    将最佳单层决策树加入到单层决策树群组
    计算alpha
    计算新的权重向量D
    更新累计类别估计值
    如果错误率为0.0就退出循环
</code></pre>
</div>

<p>实际代码：</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">adaboostTrainDS</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span> <span class="n">classLabels</span><span class="p">,</span> <span class="n">numIt</span><span class="o">=</span><span class="mi">40</span><span class="p">):</span>
    <span class="n">weakClassArr</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">m</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">dataArr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">D</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="n">m</span><span class="p">)</span>
    <span class="n">aggClassEst</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numIt</span><span class="p">):</span>
        <span class="n">bestStump</span><span class="p">,</span><span class="n">error</span><span class="p">,</span><span class="n">classEst</span><span class="o">=</span><span class="n">buildStump</span><span class="p">(</span><span class="n">dataArr</span><span class="p">,</span><span class="n">classLabels</span><span class="p">,</span><span class="n">D</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">"D:"</span><span class="p">,</span><span class="n">D</span><span class="o">.</span><span class="n">T</span>
        <span class="n">alpha</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">log</span><span class="p">((</span><span class="mf">1.0</span><span class="o">-</span><span class="n">error</span><span class="p">)</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">error</span><span class="p">,</span><span class="mf">1e-16</span><span class="p">)))</span>
        <span class="n">bestStump</span><span class="p">[</span><span class="s">'alpha'</span><span class="p">]</span>   <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">weakClassArr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bestStump</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">'classEst:'</span><span class="p">,</span><span class="n">classEst</span><span class="o">.</span><span class="n">T</span>
        <span class="n">expon</span><span class="o">=</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">classEst</span><span class="p">)</span>
        <span class="n">D</span><span class="o">=</span><span class="n">multiply</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">expon</span><span class="p">))</span>
        <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="o">/</span><span class="n">D</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
        <span class="n">aggClassEst</span><span class="o">+=</span><span class="n">alpha</span><span class="o">*</span><span class="n">classEst</span>
        <span class="k">print</span> <span class="s">"aggClassEst:"</span><span class="p">,</span> <span class="n">aggClassEst</span><span class="o">.</span><span class="n">T</span>
        <span class="n">aggErrors</span><span class="o">=</span><span class="n">multiply</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">aggClassEst</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mat</span><span class="p">(</span><span class="n">classLabels</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">errorRate</span><span class="o">=</span><span class="n">aggErrors</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span><span class="o">/</span><span class="n">m</span>
        <span class="k">print</span> <span class="s">"total error:"</span> <span class="p">,</span> <span class="n">errorRate</span><span class="p">,</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span>
        <span class="k">if</span> <span class="n">errorRate</span><span class="o">==</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">return</span> <span class="n">weakClassArr</span>
</code></pre>
</div>
<ol>
  <li>其中numIt是迭代的次数；</li>
  <li>DS代表单层的决策树，当然可以用其他分类器，所有分类器都可以作为AdaBoost的基分类器；</li>
  <li>向量D很重要，包含了每个点的分类权重；</li>
  <li>alpha值是基分类器的权重。</li>
</ol>

<hr />

<h2 id="section-3">7.5非均衡问题</h2>
<p>在大多数情况下，不同分类的代价并不相等。我们需要度量分类器性能的方法。</p>

<h3 id="roc">7.5.1其他分类器性能度量的指标：正确率、召回率和ROC曲线</h3>
<ol>
  <li>
    <p>混淆矩阵（confused matrix）是个不错的度量方法。<br />
 <img src="images/confused2.png" alt="image" /><br />
如果非对角线元素都是0，那么就是一个完美的分类器。还可以用下图来直观表示：<br />
 <img src="images/confused.png" alt="image" /></p>
  </li>
  <li>对于一个二类问题的混淆矩阵，有<br />
 <img src="images/confused3.png" alt="image" /></li>
  <li>正确率（precision），它等于TP/(TP+FP)</li>
  <li>召回率（recall），它等于TP/(TP+FN)</li>
  <li>构造正确率或者召回率高的分类器是容易的，但很难保证两者同时成立。</li>
  <li>ROC曲线：<br />
<img src="images/confused4.png" alt="image" />   <br />
图中的ROC曲线中给了两条线，横轴是伪正例的比例（假阳率=FP/(FP+TN)），而纵轴是真阳例的比例（真阳率=TP/(TP+FN)）。虚线是随机猜测的结果曲线。 <br />
在理想情况下，最佳的分类器应该尽可能的位于左上角。 <br />
对于不同的ROC曲线比较的一个指标是ROC曲线下的面积（Area Under the Curve）。一个完美分类器的AUC是1.0，随机猜测的AUC是0.5。</li>
</ol>

<h3 id="section-4">7.5.2基于代价函数分类器决策控制</h3>

<p><img src="images/daijia.png" alt="image" /></p>

<p>表中的第二个与第一个的代价函数是不同的，我们可以基于代价函数来找到拥有最小代价的分类器，用来更新权重D。</p>



  </div>


  <div id="menuIndex" class="sidenav">
    <div class="myinfo"><center>
      <div id="avatarHolder" class="avatar circle" style="width: 0px; height: 0px; box-shadow: none; margin-bottom: 20px;"></div>
      <a href="/index.html" title="Homepage"><i class="icon-home icon-large"></i> Home</a>
      <a href="http://www.linkedin.com/in"><i class="icon-linkedin-sign icon-large"></i> Profile</a>
      <a href="https://github.com/"><i class="icon-github icon-large"></i> Code</a>
      <a href="mailto:liubaojie2016@163.com"><i class="icon-envelope icon-large"></i> Mail</a>
    </center></div>
    <div id="menu"></div>
  </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


<!-- 多说评论框 start -->


</body>


</html>
